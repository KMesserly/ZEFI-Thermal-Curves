---
title: "Piecewise Regression QPoisson Error on Real Data using STAN Directly"
author: "Michael Gilchrist"
date: "date: 2022-12-20"
output: pdf_document
---

```{r setup, include=FALSE, }

knitr::opts_chunk$set(
  warning = TRUE, # show warnings
  message = TRUE, # show messages
  error = TRUE, # do not interrupt generation in case of errors,
  echo = TRUE  # show R code
)


if(interactive()) default::default(.ess.eval) <- list(max.deparse.length=2E2, output = TRUE)

```
# Goal

- Fit two piece quasipoisson to data

## Recap

# Set up

## Install libraries

```{r, message = FALSE}

# install packages user might not have by replacing FALSE with TRUE

## load libraries
library(stats)
library(MASS) # provides negative binomial fitting:  glm.nb
library(ggplot2)
library(ggpubr)
library(grid)
library(gridExtra)
library(GGally)
library(broom)
library(tidyverse)
library(viridisLite)
library(cmdstanr)
library(rstan)
options(mc.cores = (parallel::detectCores()-2))
rstan_options(auto_write = TRUE)
library(loo)


## options(ggplot2.continuous.colour="viridis",
##        ggplot2.discrete.colour="viridis",
##        ggplot2.scale_fill_discrete = scale_fill_viridis_d,
##        ggplot2.scale_fill_continuous = scale_fill_viridis_c)

library(reshape2)
library(lme4)
library(latex2exp)

```

## Load Data

```{r}
load(file.path("input", "data.processing_2022-12-15.Rda"),
     verbose = TRUE)


motif_data
```


# Examine Data

## Create Working Dataset

```{r}

filter_data <- TRUE

if(filter_data) {
  males_filtered_disp <- motif_stats_40C %>%
    filter(dispersion < 50) %>%
    pull(male)

  males_filtered_mean <- motif_stats %>%
    filter(mean > 10) %>%
    pull(male)

  male_vector <- intersect(males_filtered_mean, males_filtered_disp)
} else {
  male_vector <- motif_data %>% select(male) %>% distinct()
}

data_ind <- motif_data %>%
    filter(male %in% male_vector) %>%
    mutate(male = droplevels(male)) %>%
    mutate(id = factor(male)) %>% 
    mutate(male = as.integer(male)) %>%
    arrange(male) %>%
    select(male, id, motif_count, temp, round, trial_round, date, counter) %>% 
  ##    left_join(male_shape, by = "male") %>%
  mutate()

stats_ind <- motif_stats %>%
    filter(male %in% male_vector) 


data_ind <- data_ind %>% filter(temp < 38) %>%
    group_by(male) %>% mutate(y0_simple.est = mean(motif_count), phi_ind = var(motif_count)/y0_simple.est) ## phi is overdispersion parameter

summary(data_ind)

summary_stats <- data_ind %>% ungroup() %>%  summarize(y0_bar = mean(y0_simple.est), y0_sd = sd(y0_simple.est), phi_bar = median(phi_ind))

n_male <- length(unique(data_ind$male))

```


# Analyze Real Data:


## Set Up Data

```{r}

data <- data_ind

motif_count <- data %>% pull(motif_count)
temp <- data %>% pull(temp)
N <- length(temp)
male <- data %>% pull(male)
## parameters to be printed

pars <- c("t0", "y0")
pars_full <- c(pars, "lp__")
```

## Assume QPoisson
 
### Males pooled: `y0`, `x0`, and $\theta$

```{r}

iter <- 15000
tmax <- 46
t0max <- tmax - 1;
t0min <- 25;
## values to use for model predictions
tp = seq(25, tmax, length.out = 100)


## For debugging
## cmodel <- cmdstan_model(stan_file = "two.piece_qpoisson.stan")

     
model <- stan(file = "two.piece_qpoisson.stan",
              model_name = "Two piece qpoisson",
              data=list(x = temp,
                        y = motif_count,
                        N = N,
                        L = 1,
                        M = 1,
                        ll = rep(1,N),
                        mm = rep(1,N),                        
                        xmax = tmax,
                        x0_min = t0min,
                        x0_max = t0max,
                        y_xmax = 0,
                        y0_min = 10,
                        sd_y0_prior = 100,
                        alpha_theta_prior = 40,
                        ##tp = tp,
                        ## max threshold value.
                        ## having it too close to xmax *sometimes* leads to sampling
                        ## near xmax, but with lower lp and very high E13) b0 values
                        y_xmax = 0,
                        sd_y_prior = 100),
              chains = 4,
              cores = 4,
              iter = iter,
              warmup = floor(iter/2),
              verbose = TRUE)
fit_qpoisson.pooled <- model

## Examine output
pars <- c("x0", "y0", "theta")
pars_full <- c(pars, "lp__")

title <- "Two piece Pooled Males"
print(title)
print(model, pars = pars)
#traceplot(model, pars = pars, inc_warmup = FALSE)

plot(model, pars = pars, point_est = "mean") #, ggtitle(title)) 
pairs(model, pars = pars_full)
stan_hist(model)

summary(fit_qpoisson.pooled, probs = c(0.025, 0.5, 0.975))$summary


```
### Males Separate


#### Separate: `y0`, and `x0`, Pooled  $\theta$

```{r}

iter <- 80000
tmax <- 46
t0max <- tmax - 1;
t0min <- 25;
## values to use for model predictions
tp = seq(25, tmax, length.out = 100)

     
model <- stan(file = "two.piece_qpoisson.stan",
              model_name = "Two piece qpoisson",
              data=list(x = temp,
                        y = motif_count,
                        N = N,
                        L = n_male,
                        M = 1,
                        ll = data$male, ## y0 and x0
                        mm = rep(1, N), ## Theta
                        xmax = tmax,
                        x0_min = t0min,
                        x0_max = t0max,
                        y_xmax = 0,
                        y0_min = 10,
                        sd_y0_prior = 100,
                        alpha_theta_prior = 10,
                        ##tp = tp,
                        ## max threshold value.
                        ## having it too close to xmax *sometimes* leads to sampling
                        ## near xmax, but with lower lp and very high E13) b0 values
                        y_xmax = 0,
                        sd_y_prior = 100),
              chains = 4,
              cores = 4,
              iter = iter,
              warmup = floor(iter/4),
              verbose = TRUE)
fit_qpoisson.separate.y0.x0 <- model

model <- fit_qpoisson.separate.y0.x0

## Examine output
pars <- c("x0", "y0", "theta")
pars_full <- c(pars, "lp__")


print(model, pars = pars)
#traceplot(model, pars = pars, inc_warmup = FALSE)
plot(model, pars = pars) #, ggtitle(title)) 

## Plot parameter estimate summaries
tmp_plot <- list()
for(par in pars) {
    tmp_plot[[par]] <- stan_plot(model, pars = par)
}
gt <- arrangeGrob(grobs = tmp_plot)
as_ggplot(gt)

## Doesn't work as expected
## tmp_plots <- stan_plot(model, pars = pars)
## tmp_plots +
##    facet_wrap(vars(grepl("x0.*", params)),
##               scales = "free")

                                        #pairs(model, pars = pars_full)
stan_hist(model, pars = pars)

               
# summary(fit_qpoisson.separate.y0.x0, probs = c(0.025, 0.5, 0.975))$summary


```


#### Separate: `y0`, `x0`, and  $\theta$

- didn't run given noise in previous one with separate `y0` and `x0`
