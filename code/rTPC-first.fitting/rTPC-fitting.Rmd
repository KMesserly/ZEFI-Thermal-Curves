---
title: "Fit rTPC models to `song_prop` after filtering"
author: "Michael Gilchrist"
date: "date: 2022-10-20"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = TRUE, # show warnings
  message = TRUE, # show messages
  error = TRUE, # do not interrupt generation in case of errors,
  echo = TRUE#,  # show R code
  ##results="asis" # Hopefully print summary() in for loops
  )


if(interactive()) default::default(.ess.eval) <- list(max.deparse.length=1E5, output = TRUE)

```
# Goal

- Evaluate trends in song_count under a (near) constant temperature.

# Set up

## Load libraries

```{r}


## load libraries
library(stats)
require(MASS) # provides negative binomial fitting:  glm.nb
library(RSQLite)  # Don't think we need this.
library(rTPC)  ## 
library(nls.multstart)
library(broom)
library(tidyverse)
library(ggplot2)
library(ggpubr)
library(grid) ## provides textGrob
library(gridExtra)
library(viridisLite)

#options(ggplot2.continuous.colour="viridis",
#        ggplot2.discrete.colour="viridis",
#        ggplot2.scale_fill_discrete = scale_fill_viridis_d,
#        ggplot2.scale_fill_continuous = scale_fill_viridis_c)

library(GGally)
library(reshape2)
library(lme4)
library(nlme)
library(gnm)
library(rsample) ## provides bootstraps()

library(RVAideMemoire) # provides overdisp.glmer()
library(humidity) ## provides VPD
library(weathermetrics)
library(latex2exp)

```
## Local Functions

- Copied from brms-first.fitting.Rmd


```{r}
## Taken from: https://stackoverflow.com/a/51330864/5322644
## Use to get model equations for models in rTPC

help_text <- function(...) {
  file <- help(...)
  path <- dirname(file)
  dirpath <- dirname(path)
  pkgname <- basename(dirpath)
  RdDB <- file.path(path, pkgname)
  rd <- tools:::fetchRdDB(RdDB, basename(file))
  capture.output(tools::Rd2txt(rd, out="", options=list(underline_titles=FALSE)))
}

get_model_eq <- function(model) {
    txt <- help_text(model)
    eqn_line <- grep("^ +rate = .*$", txt, value = TRUE)
    eqn <- gsub("(^ +rate = | *$)", "", eqn_line) %>%
        gsub("\\.([^0-9])", " * \\1", .) %>%
        gsub("\\_", "", .)    
    df <- tibble(model = model, eq = eqn)
    return(df)
}


plot_brms_fit <- function(brmsfit) {
    plist = list()

    plist[[1]] <- plot(brmsfit, title = paste("brm() summary: ", prior_index), ask = FALSE)
    return(plist)
}

plot_stan_fit <- function(stanfit) {
    plist = list();
    i <- 1
    
    plist[[i]] <-  plot(stanfit, title = paste("stan() summary: ", prior_index))


    ## Plotting routines from: www.weirdfishes.blog/blog/fitting-bayesian-models-with...
    ##
    mack_diagnostics <- rstan::get_sampler_params(stanfit) %>% 
        set_names(1:4) %>% 
        map_df(as_tibble,.id = 'chain') %>% 
        group_by(chain) %>% 
        mutate(iteration = 1:length(chain)) %>% 
        mutate(warmup = iteration <= warmup) %>%
        mutate()
    i <- i+ 1
    
    plist[[i]] <- mack_diagnostics %>% 
        group_by(warmup, chain) %>% 
        summarise(percent_divergent = mean(divergent__ >0)) %>% 
        ggplot() +
        geom_col(aes(chain, percent_divergent, fill = warmup), position = 'dodge', color = 'black') + 
        scale_y_continuous(labels = scales::percent, name = "% Divergent Runs")  + 
        scale_fill_npg()

    i<- i+1
    plist[[i]] <- mack_diagnostics %>% 
        ggplot(aes(iteration, treedepth__, color = chain)) + 
        geom_line() + 
        geom_hline(aes(yintercept = max_treedepth), color = 'red') + 
        scale_color_locuszoom()

    return(plist)

}

```


## Plotting settings

```{r}

## From: https://data-se.netlify.app/2018/12/12/changing-the-default-color-scheme-in-ggplot2/

theme_set(theme_minimal(base_size = 9))
theme_update(
    plot.title = element_text(size = rel(1.1)),
    plot.subtitle = element_text(size = rel(1)))

if(!exists("old_opts")) old_opts <- options()  # save old options

options(ggplot2.continuous.colour="viridis")
options(ggplot2.continuous.fill = "viridis")
options(ggplot2.discrete.colour="viridis")
options(ggplot2.discrete.fill = "viridis")


```
## Create Model Tibble

```{r}
model_def_tbl <- lapply(get_model_names(), get_model_eq) %>% bind_rows(, .id = NULL) %>% tibble()
print(model_def_tbl, n = 200, width = 200)

str_rm <- c("exp", "[0-9.]+", "log(2|10|)", "sin", "abs", "pi", "temp")
pattern <- paste0("\\b", paste0(str_rm, collapse = "\\b|\\b"), "\\b")
n_param  <- stringi::stri_extract_all_words(model_def_tbl$eq) %>%
    lapply(., unique) %>%
    lapply(., paste, collapse= " ") %>%
    str_replace_all(., pattern, "") %>%
    str_count(., boundary("word"))
model_tbl <- bind_cols(model_def_tbl, n_param= n_param)

```

## Load Data

```{r}
load(file.path("input", "data.processing_2022-11-09.Rda"),
     verbose = TRUE)

```


# Examine Data

## Create Working Dataset

```{r}

males_filtered_disp <- song_stats_40C %>%
    filter(dispersion < 50) %>%
    pull(male)

males_filtered_mean <- song_stats %>%
    filter(mean > 10) %>%
    pull(male)
males_filtered <- intersect(males_filtered_mean, males_filtered_disp)

data_ind <- song_data %>% filter(male %in% males_filtered)

## copy data frame and assign `male =  "combined")
data_comb <- data_ind %>% mutate(male = "combined")

```


# Analyze Data: Combined

```{r}
data <- data_comb



```

