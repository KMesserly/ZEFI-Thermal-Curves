---
title: "Piecewise Regression with Negative Binomial Type I Error on Real Data using `brms` Custom Family"
author: "Michael Gilchrist"
date: "Created: 2023-02-28; Compiled: `r date()`"
output: pdf_document
---

```{r setup, include=FALSE, }

knitr::opts_chunk$set(
  warning = TRUE, # show warnings
  message = TRUE, # show messages
  error = TRUE, # do not interrupt generation in case of errors,
  echo = TRUE  # show R code
)


if(interactive()) {
  default::default(.ess.eval) <- list(max.deparse.length=2E2, output = TRUE)
  output_dir = "output"  
} else { 
  output_dir = "output/render"  
}

```
# Goal

- Fit two piece negative binomial type 1 formulation to data
- From 2023-02-28 version of `nbinom_type1.R`

> Negative Binomial distribution parameterized by mean (mu) and overdispersion parameter (theta).
> This parameterization is referred to as NEGBIN type I (Cameron and Trivedi, 1998) as cited by
> https://doi.org/10.1080/03610926.2018.1563164
> ##
> `x ~ nbinom_type1(mu, theta)`, where `E(x) = mu, Var(x) = (theta + 1) mu`
> This should not be confused with the mu and shape parameterization of nbinom in R or the 'alternative' NB (`neg_binomial_2_...`) in stan
> Note using disp instead of theta because using theta gives the error
> > Error: Currently 'dirichlet' is the only valid prior for simplex parameters. See help(set_prior) for more details.
> when trying to fit the model.


## Recap

- Earlier work generated poor estimates of `x0`.
- Visualization of data and model fit indicates there's very little information on x0.
- While I can generate predictions of expected values, I can't generate expected values of the data itself.
  I expect this is due to fact that we generate parameters which result in y = `NaN`
- TODO
  - Figure out better model definition that avoids generating NaN values.
    I expect this can be done by imposing a better prior on `x0|male`.
  - Allow disp to vary between males.
  
## Insights

- When the `disp` (dispersal or `theta`) gets unrealistically large, we get the emergence of a bimodal distribution at both ends of `x0` values.  
Even though we included this value, it is very unlikely to be 25C values.
I interpret this to mean that when things are really noisy (high `theta`), one way to interpret the data is that one set of males has a very long (presumably slow) decline.
It would be good to look at the correlations via `pairs()`.
- To me this is consistent with the infomal knowledge that the 


# Set up

## Install libraries

```{r, message = FALSE}

# install packages user might not have by replacing FALSE with TRUE

## load libraries
library(stats)
library(MASS) # provides negative binomial fitting:  glm.nb
library(ggplot2)
library(ggpubr)
library(grid)
library(gridExtra)
library(GGally)
library(broom)
library(tidyverse)
library(viridisLite)
library(cmdstanr)
library(rstan)
options(mc.cores = (parallel::detectCores()-2))
rstan_options(auto_write = TRUE)
library(brms)
library(loo)


## options(ggplot2.continuous.colour="viridis",
##        ggplot2.discrete.colour="viridis",
##        ggplot2.scale_fill_discrete = scale_fill_viridis_d,
##        ggplot2.scale_fill_continuous = scale_fill_viridis_c)

library(reshape2)
library(lme4)
library(latex2exp)

```

## Source family

```{r}

source("../../../custom-brms-families/families/nbinom_type1.R")
```
## Load Data

```{r}
sapply(file.path("input", dir("input")),
       load, verbose = TRUE, envir = .GlobalEnv)

head(stats_ind)
names(stats_ind)

head(data_ind)
names(data_ind)


```



# Fit Models

- Code derived from `../2023-02-28_fit.real.data.using.nbinom_type1/brms_two.piece_fit.nbionm_type1.Rmd`


## Set up functions, parameters, and results tibble 

```{r}

data_stan <- data_ind %>% rename(y = motif_count, x = temp) %>%
  mutate(male = factor(male))
males <- data_stan$male

xmax <- 46 # maximum value for x0
xignore <- 39 # x value above which data is ignored in one_piece model
    
stan_two_piece_func <- paste0(" real  two_piece(real x, real x0, real y0) {
 real xmax = ", xmax, "; ## paste in value for xmax\n
 return(y0 * (xmax - fmax(x0, x))/(xmax - x0));
 } ")

stan_one_piece_func <- paste0(" real  one_piece(real y0) {
 return(y0);
 } ")

stan_asymptotic_func <- paste0(" real  asymp(real x, real phi, real y0) {
 real xmax = ", xmax, "; ## paste in value for xmax\n
 return(y0 * (1 - exp( - phi * (xmax - x))) );
 } ")



models <- c("one_piece", "two_piece", "asymptotic") #, "one_piece") #, "asymptotic")
sampling_dists <- c("nbinom_type1") ##, "com_poisson") ## lognormal doesn't work since the counts can be 0.
flags_x0 <- c("uniform_1",
              "groups_1", ## this doesn't work with x0_Intercept prior, suggests error in priors
              #"groups_2a",
              #"groups_2b",
              "individual")

flags_y0 <- switch(1,
                   c("individual"),
                   c("uniform_1", "groups_1", "individual")
                   )

values_disp <- switch(4,
                      c(9), # matches rstan runs
                      c(0.01, 0.1, 0.25), # used in exploring model behavior
                      c(0.1, "flat"), #, 0.1, 1)
                      c("flat"))

flags_disp <- switch(2,
                   c("individual"),
                   c("uniform_1", "groups_1", "individual")
                   )

## whether to filter males with large disp values estimated using one piece model
filter_male <- c(FALSE, TRUE)

N <- length(data)

fit_tbl <- crossing(model = models,
                    sampling_dist = sampling_dists,
                    x0_flag = flags_x0, y0_flag = flags_y0,
                    disp_value = values_disp,
                    disp_flag = flags_disp,
                    desc = "NA_character",
                    filter_male = filter_male,
                    y0_group_list = list(NA), #tbl_tmp, #list(NA),
                    x0_group_list = list(NA),
                    fit = list(NA),
                    llik = list(NA),
                    r_eff = list(NA),
                    loo = list(NA)
                    )


```

### Run fits

```{r, message = FALSE }

run_fits = TRUE
force_load = FALSE  #reload fit_tbl even if it already exits
save_fits = TRUE


if(run_fits) {
  infile_tbl <- NULL
  outfile_tbl <- file.path(output_dir, paste0("fit_tbl_", Sys.Date(), ".Rda"))
} else {
  infile_tbl <- file.path(output_dir, paste0("fit_tbl_", Sys.Date(), ".Rda"))
  outfile_tbl <- NULL
}


sampling = "nbinom_type1"

flags_x0_used <- c("individual", "groups_1", "uniform_1") #
flags_y0_used <- c("individual")
values_disp_used <- values_disp
flags_disp_used <- c("individual", "groups_1", "uniform_1")
models_used <- c("asymptotic", "two_piece") #c("one_piece", "two_piece") #, "two_piece")

## males whose E(disp) in one_piece is < 4
males_keep <- c("T234", "T236", "T237", "T244", "T247", "T257", "T260")

fit_index <- 0

for(filter_male in c(FALSE, TRUE) {
  for(model in models_used) {

    print(model)
    switch(model,           
           two_piece = {
             stan_func <- stan_two_piece_func
             warmup <- 4000 #floor(3/4 * iter)
             iter <- warmup + 3000
             adapt_delta <- 0.85
             thin <- 4
           },
           one_piece = {
             stan_func <- stan_one_piece_func
             warmup <- 2000
             iter <- warmup + 2000
             thin <- 4
             adapt_delta <- 0.9             
           },
           asymptotic = {
             stan_func <- stan_asymptotic_func
             warmup <- 2000
             iter <- warmup + 2000
             thin <- 4
             adapt_delta <- 0.9
           }
           
           )
    for(disp_flag in flags_disp_used) {  

      print(stan_func)
      
      for(x0_flag in flags_x0_used) {
        ## define variable for labeling figures
        x0_label <- ifelse(model == "one_piece", "NA", x0_flag)
        
        for(y0_flag in flags_y0_used) {

          print_get_prior <- TRUE ## reset value
          print_prior_summary <- TRUE
          
          for(disp_value in values_disp_used) {

            ## used when loading fits
            fit_index <- fit_index + 1;
            ## Set up variables for saving model and fit

            desc_short <- paste0("x0: " , x0_label, "; y0: ", y0_flag, "disp_flag:", disp_flag, "; disp prior: ", disp_value, "filter: ", filter_male) 
            desc <- paste0(sampling, "; ", model, "; ", desc_short)

            filename_desc <- gsub("_", "-", desc) %>%
              gsub("; ", "_", .) %>%
              gsub(":? ", "-", .)
            
            curr_row <- which(fit_tbl$model == model &
                                fit_tbl$sampling_dist == sampling &
                                fit_tbl$x0_flag == x0_flag &
                                fit_tbl$y0_flag == y0_flag &
                                fit_tbl$disp_value == disp_value &
                                fit_tbl$disp_flag == disp_flag &
                                fit_tbl$filter_male == filter_male)
            fit_tbl[ curr_row, ]$desc <- desc

            print(desc)

            if(run_fits) {

              
              print("Fitting Models")
              switch(sampling,
                     "nbinom_type1"= {
                       family <- nbinom_type1(link = "identity", link_disp = "log")
                       adapt_delta <- adapt_delta #0.95 ## will decreasing value increase ESS? Seems like it
                       iter <- iter
                       warmup <- warmup
                       thin <- thin
                       n_cores <- 4 ## set to 1 if getting errors from stan in order to see relevant message.
                       n_chains <- n_cores
                       nbinom_type1_vars <-
                         stanvar(scode = paste(
                           stan_func,
                           stan_nbinom_type1, sep = "\n"),
                           block = "functions")
                     }
                     )

              ## Refresh data in case x0_group or y0_group are all set to 1
              data <- data_stan

              if(model == "one_piece") data <- data %>% filter(x < xignore)
              if(filter_male) data <- data %>% filter(male %in% males_keep)
              

              print("Set flags based on fitted model structure")
              if(x0_flag %in% c("uniform_1", "groups_1")) data <- mutate(data, x0_group = 1)
              if(y0_flag %in% c("uniform_1", "groups_1")) data <-mutate(data, y0_group = 1)
              if(x0_flag %in% c("individual")) data <- mutate(data, x0_group = male)
              if(y0_flag %in% c("individual")) data <- mutate(data, y0_group = male)



              ## Note we need to put a tibble into a list because row updates, even if doing
              ## just one cell, require a list format.
              ## Haven't defined "y0_group" or "x0_group" variables
              if(FALSE) {
                fit_tbl[[curr_row, "x0_group_list"]] <- list(unique(data[, c("male", "x0_group")]))
                fit_tbl[[curr_row, "y0_group_list"]] <- list(unique(data[, c("male", "y0_group")]))
              }
              
              print("Define parameter formulas")
              x0_form <- switch(x0_flag,
                                uniform_1 = formula(x0 ~ 1),
                                uniform_2 = formula(x0 ~ 0 + x0_group),
                                ## `0 + Intercept` avoids prior being defined on centered data
                                groups_1 = formula(x0 ~ 0 + Intercept + (1|male)), 
                                groups_2 = formula(x0 ~ 0 + Intercept + (1|male) + x0_group),
                                individual = formula(x0 ~ 0 + male) ## Do not use 1 + male!
                                )

              phi_form <- formula(deparse(x0_form) %>% gsub("x0", "phi", .))

              y0_form <- switch(y0_flag,
                                uniform_1 = formula(y0 ~ 1),
                                ## `0 + Intercept` avoids prior being defined on centered data
                                uniform_2 = formula(y0 ~ 0 + y0_group),
                                groups_1 = formula(y0 ~ 0 + (1| male)), 
                                groups_2 = formula(y0 ~ 0 + (1| male) + y0_group),
                                individual = formula(y0 ~ 0 + male)
                                ## `-1 + ` gives me the error:
                                ## Warning in parallel::mclapply(1:chains, FUN = callFun, mc.preschedule = FALSE,  :
                                ##  4 function calls resulted in an error
                                ## Error in FUN(X[[i]], ...) : 
                                ##  trying to get slot "mode" from an object (class "try-error") that is not an S4 object
                                ## should I use `0 +` or `-1 +` ?
                                )

              threshold_form <- switch(model,
                                       two_piece = x0_form,
                                       one_piece = NULL,
                                       asymptotic = phi_form
                                       )


              disp_form <- switch(disp_flag,
                                  uniform_1 = formula(disp ~ 0 + Intercept),
                                  groups_1 = formula(disp ~ 0 + Intercept + (1|male)),
                                  individual = formula(disp ~ 0 + male)
                                  )

              nlform <- switch(model,
                               two_piece = bf(y ~ two_piece(x, x0, y0), nl = TRUE),
                               one_piece = bf(y ~ one_piece(y0), nl = TRUE),
                               asymptotic = bf(y ~ asymp(x, phi, y0), nl = TRUE)
                               ) +
                threshold_form +
                disp_form +
                y0_form


              
              print("Define priors")

              prior_string <- ifelse(disp_value == "flat",
                                     "uniform(0, 20)",
                                     paste0("exponential(", disp_value, ")")
                                     )
              
              disp_priors <- set_prior(prior_string,
                                       dpar = "disp", lb = 0, ub = 20)

              ## x0 only used in two_piece model
              x0_prior <- switch(x0_flag,
                                 uniform_1 = NULL,
                                 uniform_2 = NULL,
                                 groups_1 = prior(student_t(3, 0, 66.7), lb = 0, ub = 3, class = "sd", nlpar = "x0"),
                                 groups_2 = NULL,
                                 individual = NULL
                                 )
              
              x0_priors <- prior(uniform(25, 45), lb = 25, ub = 45, nlpar = "x0") + x0_prior

              phi_priors <- prior(uniform(0.1, 100), lb = 0.1, ub = 50, nlpar = "phi")
              
              y0_priors <- switch(y0_flag,
                                  uniform_1 = prior(normal(150, 100), nlpar = "y0"),
                                  uniform_2 = NULL,
                                  groups_1 = NULL,
                                  groups_2 = NULL,
                                  individual = switch(2,
                                                      prior(normal(200, 200), nlpar = "y0", lb = 10, ub = 500), ## save value as with origina rstan fits
                                                      prior(uniform(10, 500), nlpar = "y0", lb = 10, ub = 500)
                                                      ),
                                  other = NULL
                                  )

              threshold_priors <- switch(model,
                                         two_piece = x0_priors,
                                         one_piece = NULL,
                                         asymptotic = phi_priors
                                         )
              
              prior <- switch(sampling,
                              "nbinom_type1" = {
                                disp_priors +
                                  threshold_priors + y0_priors
                              })
              

              if(print_get_prior) {
                print(get_prior(nlform,
                                data = data,
                                family = family
                                ),
                      max = 100)
                print_get_prior <- FALSE # will get reset
              }
              
              save_model <-paste0(paste0(output_dir, "/stan/brms", model, sampling, switch(model, two_piece = x0_flag, one_piece = "NA"), y0_flag, disp_value, sep = "_"), ".stan")
              #make_stancode( .... save_model = save.model)
              fit <- brm(nlform,
                         data = data,
                         ## `link` refers to the mapping of the expectation of the distribution: log, sqrt, identity, softplus
                         ## link_shape corresponds to `phi` of `stan`'s
                         ## Negbinomial_2
                         ## Defining `phi = mu/theta` creates a quasipoisson
                         ## distribution with overdispersion parameter (1 +theta)
                         family = family, #negbinomial(link = "identity", link_shape = "identity"),
                         prior = prior,
                         stanvars = nbinom_type1_vars,
                         iter = iter,
                         warmup = warmup,
                         thin = thin,
                         silent = ifelse(interactive(), 1, 2), # 0, 1, or 2. 1 is default
                         control = list(adapt_delta = adapt_delta,
                                        max_treedepth = 12
                                        ##model_name = desc ## Incorrect way to set this.
                                        ),
                         ## Only print out sampling progress if in interactive mode
                         refresh = ifelse(interactive(),max(iter/5, 1), 0),
                         chains = n_chains,
                         cores = n_cores,
                         save_model = save_model
                         )

              print(desc)
              # print("Prior Information")
              # print(prior_summary(fit))
              print("Fit Information")
              print(fit)
              
              #fit_exp <- expose_functions(fit) , vectorize = TRUE)
              #fit_cr <- add_criterion(fit_exp, c("loo", "waic"))
              fit_tbl[[curr_row, "fit"]] <- list(fit)
              ## Print current warnings
              warnings(summary)
              ## Clear warnings()

              ## End if(run_fit)
            } else {
              print("Working with Pre-existing Fits")

              
              ## Try to assign from local memory.
              fit <- fit_tbl[[curr_row, "fit"]][[1]]

              ## Load fit if undefined or desired
              if(is.na(list(fit)) | force_load) {
                print("Loading Models")            
                #if(fit_index ==1)
                load(file = infile_tbl)
                fit <- fit_tbl[[curr_row, "fit"]][[1]]
              }
            }

            if(is.na(list(fit))) {
              warning(paste0("model fit ", desc, "does not exist.\n Skipping."))
            }else {
              ## Print and plot results, regardless of which fits one uses           
              print(desc)
              if(print_prior_summary) {
                print("Fit Prior Information")
                print(prior_summary(fit)) # %>% filter(nlpar!="y0"))
                print_prior_summary <- TRUE
              }
              print("Fit Information")
              print(summary(fit)) #, pars = "x0*"))          %>% filter(nlpar!="y0"))
              fit_stan <- fit$fit
              #clean up variable names
              fit_stan_rename <-
                fit_stan %>%
                setNames(gsub("b_", "", names(.)) %>%
                           gsub("(x0|phi|y0)_male(T[0-9]{3})", "\\2_\\1", .) %>%
                           gsub("__", "_", .) %>%
                           gsub("r_male_(x0|phi|y0)\\[(T[0-9]{3}),Intercept\\]", "\\2_\\1_r", .) %>%
                           gsub("\\.", " ", .))

              ##
              vars_fit <- names(fit_stan_rename) %>% na.omit(.) %>% sort(., decreasing = TRUE)
              ncol <- 4 
              hist <-  stan_hist(fit_stan_rename,
                                 pars = vars_fit,
                                 bins = 30,
                                 ncol = ncol) +
                ggtitle(desc_short)
              print(hist)
              filename <- paste0("histogram_", filename_desc, ".pdf")
              ggsave(filename = filename, path = file.path(output_dir, "figures"), dpi=300)

              list_plot <- list()
              for(male in males) {
                ##print(male);
                list_plot[[male]] <- pairs(fit, variable = male, regex = TRUE)
              }

              grid_plot <- cowplot::plot_grid(
                plotlist = list_plot,
                ncol = 2) +
                ggtitle(desc_short)
              print(grid_plot)
              filename <- paste0("grid.plot_", filename_desc, ".pdf")
              ggsave(filename = filename, path = file.path(output_dir, "figures"), dpi=300)
              
            }
            #end else for fitting
            
          }
        }
      }
    }
  }
}
print(outfile_tbl)

if(save_fits) save(fit_tbl, file = outfile_tbl)
```


## Exit rendering
```{r}

knitr::knit_exit()

```
