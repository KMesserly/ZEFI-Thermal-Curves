---
title: "Visualize Piecewise Regression with Negative Binomial Type I Error on Real Data using `brms` Custom Family"
author: "Michael Gilchrist"
date: "Created: 2023-03-29; Compiled: `r date()`"
output: pdf_document
---

```{r setup, include=FALSE, }

knitr::opts_chunk$set(
  warning = TRUE, # show warnings
  
  message = TRUE, # show messages
  error = TRUE, # do not interrupt generation in case of errors,
  echo = TRUE,  # show R code
  fig.width = 7.5,
  fig.height = 10
)


if(interactive()) {
  default::default(.ess.eval) <- list(max.deparse.length=2E2, output = TRUE)
  output_dir <- "output"  
} else { 
  output_dir <- file.path("output", "render")
}

input_dir <- file.path("input")
```
# Goal

- Visualize two piece negative binomial type 1 formulation to data

## Recap

- Update to `2023-03-09_visualize.2023-02-28-fit...` for use with more recent fits in `2023-03-18_fit...` folder.
- Part of challenge is bimodal nature of some male's `x0` and `y0` fits
  - `T235` and `T236` in particular




## Insights


# Set up

## Install libraries

```{r, message = FALSE}

# install packages user might not have by replacing FALSE with TRUE

## load libraries
library(stats)
library(MASS) # provides negative binomial fitting:  glm.nb
library(ggplot2)
library(ggpubr)
library(grid)
library(gridExtra)
library(ggExtra)
library(cowplot)
library(GGally)
library(RColorBrewer) ## needed to have more than 8 colors with `palette="Set2"
library(broom)
library(tidyverse)
library(viridisLite)
library(cmdstanr)
library(rstan)
options(mc.cores = (parallel::detectCores()-2))
rstan_options(auto_write = TRUE)
library(brms)
library(bayesplot)
library(tidybayes)
library(loo)
library(modelr)

## options(ggplot2.continuous.colour="viridis",
##        ggplot2.discrete.colour="viridis",
##        ggplot2.scale_fill_discrete = scale_fill_viridis_d,
##        ggplot2.scale_fill_continuous = scale_fill_viridis_c)

library(reshape2)
library(latex2exp)

ggplot2::theme_set(theme_default(base_size = 10))
## Restore theme settings
## ggplot2::theme_set(theme_default())

n_cores <- 4

```

## Source family

```{r}

source("../../../custom-brms-families/families/nbinom_type1.R")

## Define fmax() om case expose_functions()

fmax <- function(x, x0) max(x, x0)

```
## Load `input`

```{r}

infile <- last(dir(file.path(input_dir, "tibbles"), "fit_tbl.*"))
infile_tbl <- file.path(input_dir, "tibbles", infile)
load(infile_tbl, verbose = TRUE)
fit_tbl_orig <- fit_tbl

fit_tbl <- fit_tbl %>% filter(!(is.na(fit))) 

```

## Define local functions

```{r}
which_tbl_row <- function(filter_male = FALSE, x0_flag = "individual", y0_flag = "individual", disp_flag = "uniform_1", disp_value = 0.01, model = "two_piece", tbl = fit_tbl) {
  which( tbl$filter_male %in% filter_male & 
          tbl$x0_flag %in% x0_flag &
          tbl$y0_flag %in% y0_flag &
          tbl$disp_flag %in% disp_flag &
          tbl$disp_value %in% disp_value &
          tbl$model %in% model
          # tbl$sampling_dist %in% sampling &
        )
}

clean_var_names <- function(fit) {
  fit %>% setNames(gsub("b_", "", names(.)) %>%
             gsub("(x0|s0|y0|disp)_male(T[0-9]{3})", "\\2_\\1", .) %>%
             gsub("__", "_", .) %>%
             gsub("r_male_(x0|s0|y0|disp)\\[(T[0-9]{3}),Intercept\\]", "\\2_\\1_r", .) %>%
             gsub("\\.", " ", .))
}
```

# Visualize Model Fits


## Set up functions, parameters, and results tibble 

```{r}

xmax <- 45.5

## Here I create a variable using a string and then access it using a string
for(name in names(fit_tbl)[1:8]) {
  # create
  var <- paste0(name, "_vec")
  assign(var, pull(fit_tbl, name) %>% unique(.))
  # access via get()
  cat(paste0(var, ": ", paste0(get(var), sep = "\n\t")))
}

```

### Print fits

```{r, message = FALSE }

pairs_include_lp = TRUE
n_rows_print_half <- 4 ## 1/2 of rows to print of prior
print_pairs_grid <- FALSE ## if true print grid, if false print row
print_full_prior <- FALSE
off_diag_fun <- "scatter" # "scatter" or "hex" for mcmc_pairs

print_mcmc_pairs <- TRUE # individual level parameters
print_mcmc_pairs_group <- TRUE # lp and group level parameters
print_mcmc_scatter <- TRUE # individual level parameters, histograms printed on margins
print_stan_hist <- FALSE

print_get_prior <- TRUE ## 
print_prior_summary <- TRUE

for(row_index in 1:nrow(fit_tbl)) {

  cat(paste("Row: ", row_index))
  
  row_values <- fit_tbl[row_index, ]
  desc <- row_values$desc
  filename_desc <- gsub("_", "-", desc) %>%
    gsub("; ", "_", .) %>%
    gsub(":? ", "-", .)
  fit_brms <- row_values$fit[[1]]
  data <- fit_brms[["data"]]
  fit_stan <- fit_brms$fit
  chains_n <- length(dimnames(fit_stan)$chains)

  desc_filename <- gsub("_", "-", desc) %>%
    gsub("; ", "_", .) %>%
    gsub(":? ", "-", .)
  desc_short <- desc %>% str_replace("nbinom_type1; two_piece; ","")

  ## two ways of specifying a title
  ## Second is more 'automatic'
    title_row <- ggdraw() + draw_label(desc_short, fontface='bold', size = 12)

  ## Print and plot results, regardless of which fits one uses           
  print(desc)
  # print(filename_desc)

  if(print_prior_summary) {
    print("Fit Prior Information")
    if(print_full_prior) {
      print(prior_summary(fit_brms)) # %>% filter(nlpar!="y0"))
    } else {
      ## Condensed version
      tmp_prior <- prior_summary(fit_brms)
      #class(tmp_prior) <- "data.frame"
      #tmp_prior <- tmp_prior %>% select(-source)
      rows_print <- unique(c(1:n_rows_print_half, nrow(tmp_prior) - (n_rows_print_half):0))
      tmp_top <- tmp_prior[1:n_rows_print_half, ] 
      tmp_bottom <- tmp_prior[rows_print[-(1:n_rows_print_half)], ]
      tmp_join <- bind_rows(tmp_top, tmp_bottom)
      tmp_join[ n_rows_print_half + 1, ] <- "..."
      ## remove brms class so we can select
      class(tmp_join) <- "data.frame"
      print(tmp_join %>% select(-source))
    }
#    print_prior_summary <- TRUE
  }

  print("Fit Information")
  print(summary(fit_brms) ) # %>% gsub("disp_value", row_values[["disp_value"]]), .) #, pars = "x0*"))          %>% filter(nlpar!="y0"))


  #clean up variable names
  fit_stan_rename <-
    fit_stan %>%
    clean_var_names()
  
  ## 

  vars_clean <- names(fit_stan_rename) %>% na.omit(.)


  male_vec <- unique(data$male) %>% as.character(.)
  ## get male specific vars (start with "T")
  vars_T <- grep("^T[0-9]{3}", vars_clean, value = TRUE)
  vars_Intercept <- grep("Intercept", vars_clean, value = TRUE)
  vars_non_T <- vars_clean[!(vars_clean %in% c(vars_T, vars_Intercept))]
  #print(vars_clean)

  ## Examine priors and exclude any constants from vars_non_T
  priors_tmp <- prior_summary(fit_brms)
  constants_non_T <- ggdist::parse_dist(priors_tmp) %>% filter(grepl("constant", .dist)) %>% pull(class)
  vars_non_T <- vars_non_T[!(vars_non_T %in% constants_non_T)]
  
  
  ## Count occurence of each male in model fit_brms
  male_instance <- sapply(male_vec, function(x) {sum(str_detect(x, string=vars_clean))})

  ## Check to make sure plotting will work and/or is desired
  if((all(male_instance > 1) | pairs_include_lp) & print_mcmc_pairs) {
    ## Use mcmc_pairs
    pairs_list <- list()
    ## update panel.boarder
    ## Note brms uses 'variable' while stanfit uses 'pars'
    for(male in male_vec) {
      # print(male)
      vars_male <- grep(male, vars_T, value = TRUE)

      ## Generate pairs() plot using mcmc_pairs()
      ## Don't use pairs.stanfit which does not return an object
      pairs_pars <- vars_male
      if(pairs_include_lp) {
        pairs_pars <- c(pairs_pars, "lp_")
      }


      ## Change text size
      # bayesplot_theme_update(text = element_text(size = 6)) #, family = "sans"))
      pairs_tmp <-  mcmc_pairs(
        fit_stan_rename,
        pars = pairs_pars,
        condition = pairs_condition(
          # plot all chains on lower diagonal
          # Could also split by draws
          chains <- list(top = 1:(chains_n), bottom = NULL)
        ),
        ## I believe div_color means color of divergent samples
        ##np_style = pairs_style_np(div_color = chain)
        ## set point size and transparency
        # grid_args = list(text = element_text(size = 20)),
        # off_diag_args are passed to mcmc_scatter() or mcmc_hex
        # off_diag_args = list(color = chain)        
        ## Try to use hex densities        
        off_diag_fun = if_else(off_diag_fun == "hex", "hex", "scatter") ## "hex" won't likely work if trying to visualize separate chains

      )

      #        bayesplot_theme_set() # same as bayesplot_theme_set(theme_default())

      # add density curves to off diagonal
      plots_tmp <- pairs_tmp$bayesplots

      ## get list of off diagonal positions
      n_tmp <- sqrt(length(plots_tmp))
      ## plot_index = lower diagonal 
      plot_index <- sapply(1:(n_tmp-1), function(x) (x+1):n_tmp+(x-1)*n_tmp) %>% unlist()
      xlab_vec <- lapply(pairs_pars, rep, times = n_tmp) %>% unlist() %>% gsub("T[0-9]{3}_","", .) 
      ylab_vec <- rev(xlab_vec)
      plots_row <- list()

      ## add contour lines
      for(j in 1:length(plot_index)) {
        i = plot_index[[j]]
        # pars = c(vars_male): list of 4 ggplot objects diagonal plots are 2 and 3
        plots_tmp[[i]] <- plots_tmp[[i]] +
             stat_density_2d(color = if_else(off_diag_fun == "hex", "black", "red"),
                          size = .75,
                          bins = 5) +
          labs(x = xlab_vec[[i]], y = ylab_vec[[i]])         

        plots_row[[j]] <- plots_tmp[[i]]
        #ggExtra::ggMarginal(plots_tmp[[i]] +
        #                                        geom_point(col="transparent") +
        #                                        geom_hex() +
        #                                        theme(legend.position = "none"), type = "histogram")
      }

      
      #text_axes <- str_remove(pairs_pars, "T[0-9]+_")
      labels_subfig <- str_extract(pairs_pars, "T[0-9]+")[[1]]
      
#      title_subfig <- ggdraw() + draw_label(text_subfig, fontface='bold')

      
      if(print_pairs_grid) {
        print("Begin `print_pairs_grid`")
        pairs_male <-bayesplot_grid(plots = plots_tmp) ## Change font size
      } else {
        ## Print summaries as a row
        pairs_male <- plot_grid(
          plotlist = plots_row,
          labels = labels_subfig,
          label_size = 8,
          hjust = -16,  # don't understand why this is so large
          label_fontface = "plain",
          nrow = 1)
      }
      pairs_list[[male]] <- pairs_male
    } # end for(male in male_vec)

    ## Combine plots across males
    p <- plot_grid(plotlist = pairs_list,
                   ncol = 2)
    
    plot_pairs_list <- plot_grid(p,
                                 labels = desc_short,
                                 ncol = 1,
                                 label_size = 10,
                                 hjust = 0,
                                 vjust = - 0.75) +
      # Add some space around the edges  
      theme(plot.margin = unit(c(1,0.5,0.5,0.5), "cm"))
    
    tmp <- plot_grid(title_row, p,  ncol = 1,
                     rel_heights=c(0.06, 1))


    print(plot_pairs_list)
    filename <- paste0("plot-pairs_", filename_desc, ".pdf")
    ggsave(filename = filename, path = file.path(output_dir, "figures"),
           width = 8, height = 11, units = "in",
           scale = 1,
           dpi=300,
           bg = "white")
  }  ## end if(all(male... for mcmc_pairs


  if(all(male_instance > 1) & print_mcmc_scatter) {

    scatter_list <- list()
    for(male in male_vec) {
      # print(male)
      vars_male <- grep(male, vars_T, value = TRUE)
     # if(length(vars_male) > 2) vars_pair <-  
      scatter_tmp <-  mcmc_hex( #was mcmc_scatter
        fit_stan_rename,
        ## Can only use two variables
        pars = c(first(vars_male), last(vars_male)) #, vars_Intercept),
      )
      
      ## ggMarginal doesn't work natively with mcmc_hex, so we need to make the
      ##  points transparent and then add a hex layer
      scatter_list[[male]] <- ggExtra::ggMarginal(scatter_tmp +
                                                    geom_point(col="transparent") +
                                                    geom_hex() +
                                                    theme(legend.position = "none"), type = "histogram")
      
    }
     
    p <- plot_grid(plotlist = scatter_list,
                   ncol = 3)
    
    plot_scatter_list <- plot_grid(title_row, p, ncol = 1, rel_heights=c(0.1, 1))

    print(plot_scatter_list)
    
    filename <- paste0("plot-scatter_", filename_desc, ".pdf")
    ggsave(filename = filename, path = file.path(output_dir, "figures"),
           width = 8, height = 11, units = "in",
           scale = 1,
           dpi=300,
           bg = "white")

    
      } # end if(print_mcmc_scatter)

  

  
  if(print_mcmc_pairs_group | length(vars_non_T > 1)) {
    pairs_list2 <- list()
    
    if(length(vars_Intercept) > 0) {
      pairs_list2[["Intercept"]] <- mcmc_pairs(
        fit_stan_rename, pars = c(vars_Intercept, "lp_"),
        off_diag_fun = c("hex"))
    }

    pairs_list2[["non-T"]] <- mcmc_pairs(fit_stan_rename,
                                         pars = vars_non_T,
                                         off_diag_fun = c("hex")
                                         ) 

    
    p <- plot_grid(plotlist = pairs_list2,
                   ncol = 1)
    plot_pairs_list2 <- plot_grid(title_row, p,  ncol = 1, rel_heights=c(0.1, 1))
      
    print(plot_pairs_list2)

        filename <- paste0("plot-pairs2_", filename_desc, ".pdf")
    ggsave(filename = filename, path = file.path(output_dir, "figures"),
           width = 8, height = 11, units = "in",
           scale = 1,
           dpi=300,
           bg = "white")
    
  }



  vars_tmp <- vars_clean %>% str_subset("y0");
  
  stan_plot(fit_stan_rename, pars = vars_tmp) +
    ggtitle("Initial Motif Counts", subtitle = desc)

  vars_tmp <- vars_clean %>% str_subset("T[0-9]+_x0")
  if(length(vars_tmp) > 0) {
    fit_stan <- stan_plot(fit_stan_rename, pars = vars_tmp) +
      ggtitle("Thresholds", subtitle = desc_short)
    
    filename <- paste0("fit-stan_", filename_desc, ".pdf")
    ggsave(filename = filename, path = file.path(output_dir, "figures"), dpi=300)
  }
  
  if(print_stan_hist) {
    ncol <- 4 
    hist <-  stan_hist(fit_stan_rename,
                       pars = vars_fit,
                       bins = 25,
                       ncol = ncol) +
      ggtitle(desc_short)
    filename <- paste0("histogram_", filename_desc, ".pdf")
    ggsave(filename = filename, path = file.path(output_dir, "figures"), dpi=300)
  }
}

```


# Plot Data and Predictions

## Set up colors

```{r}

## "Set2" only has 8 colors by default.
## This code expands that ability, based on: https://www.datanovia.com/en/blog/easy-way-to-expand-color-palettes-in-r/
n_colors <- 11 # length(male_vec)
colors_male <- colorRampPalette(brewer.pal(8, "Set2"))(n_colors)
```

Data suggests that disp should vary between males?


## Plot Data and Expected Values vs. Temperature

```{r}

curr_row_max <- switch(2,
                       2,
                       nrow(fit_tbl)
                       )

for(curr_row in 1:curr_row_max) {


}


generate_epred_data <- function(curr_row = 1, fit_tbl = NULL) {
  curr_desc <- fit_tbl[[curr_row, "desc"]]
  curr_desc_short <- curr_desc %>% str_replace("nbinom_type1; two_piece; ","")
  fit_brms <- fit_tbl[[curr_row, "fit"]][[1]]

  expose_functions(fit_brms, vectorize = TRUE, show_compiler_warnings = FALSE)
  data_fit_brms <- fit_brms$data


  ## Create grid of x values for epred/predictions

  data_grid <- data_fit_brms %>%
    group_by(male) %>%
    data_grid(x = seq_range(c(20, 46), n = 51))


  ## add expected values
  data_epred <- data_grid %>%
    add_epred_draws(object = fit_brms, ndraws = 500, cores = n_cores)

  return(data_epred)
}


  ## Plot
  male_vec_tmp <- male_vec #[c(1, 5, 8)]
  ## Only plot a few males due to large size of `data_epred`
  data_epred_tmp <- data_epred %>%
    filter(male %in% male_vec_tmp)

  data_fit_brms_tmp <- data_fit_brms %>% filter(male %in% male_vec_tmp)
  y_max <- max(data_epred_tmp$.epred)*1.1

  plot_tmp <- ggplot(data = data_epred_tmp, aes(x = x, y = .epred, color = male)) +
    ## Combine Scatter Plots and Model vs Data Plots
    stat_lineribbon(aes(y=.epred)) +
    scale_fill_brewer(palette = "Greys") +
    scale_color_manual(values = colors_male) +
    #scale_color_brewer(palette = "Set2") +
    geom_point(data = data_fit_brms_tmp,
               aes(x = x, y = y), color = "red") + 
    ylim(0, y_max)

  plot_data_vs_epred <- plot_tmp + facet_wrap(vars(male)) +
    labs(title = "Data vs. Expected Values", subtitle = curr_desc_short) 
  last_plot()
  filename <- paste0("data.and.epred-vs-x_", filename_desc, ".pdf")
  ggsave(filename = filename, path = file.path(output_dir, "figures"),
         width = 8, height = 11, units = "in",
         scale = 1,
         dpi=300,
         bg = "white")
}
```


## Plot Data and Simulated Values vs. Temperature

```{r}


for(curr_row in 1:curr_row_max) {
  
  curr_desc <- fit_tbl[[curr_row, "desc"]]
  curr_desc_short <- curr_desc %>% str_replace("nbinom_type1; two_piece; ","")
  fit_brms <- fit_tbl[[curr_row, "fit"]][[1]]

  if(FALSE) {
    object.size(fit_brms)
    ## Unclear where function information is stored
    ## Fit object does not seem to change in size
    expose_functions(fit_brms, vectorize = TRUE, show_compiler_warnings=FALSE)
    object.size(fit_brms)
  }
  
  data_fit_brms <- fit_brms$data


  ## Create grid of x values for epred/predictions

  #dataframe_tmp <- crossing(x = seq_range(c(20, 30), n = 51), draw = 1:3, male = male_vec)
  
  data_grid <- data_fit_brms %>%
    group_by(male) %>%
    data_grid(x = seq_range(c(20, 45.9), n = 51)) %>%  #, .model = fit_brms) %>% 
    ungroup() 

  
  

  ## add simulated values
  ## Only getting 1 draw/(male temp)
  data_pred <- data_grid %>%
    add_predicted_draws(object = fit_brms)

  
  y_max <- max(data_pred$.prediction, na_rm = TRUE)*1.1

  plot_tmp <- ggplot(data = data_pred, aes(x = x, y = .prediction, color = male)) +
    ## Combine Scatter Plots and Model vs Data Plots
    stat_lineribbon(aes(y=.prediction), .width = c(.95), color = "#08519C") +
    scale_fill_brewer(palette = "Greys") +
    scale_color_manual(values = colors_male) +
    #scale_color_brewer(palette = "Set2") +
    geom_point(data = data_fit_brms,
               aes(x = x, y = y), color = "red") + 
    ylim(0, y_max)

  plot_data_vs_pred <- plot_tmp + facet_wrap(vars(male)) +
    labs(title = "Data vs. Simulated Values", subtitle = curr_desc_short) 
  last_plot()

  filename <- paste0("data-simulated-vs-x_", filename_desc, ".pdf")
  ggsave(filename = filename, path = file.path(output_dir, "figures"),
         width = 8, height = 11, units = "in",
         scale = 1,
         dpi=300,
         bg = "white")
}
```


## Exit rendering
```{r}

knitr::knit_exit()

```




## Create Model vs. Data Plots

```{r}

plot_model <- list()

list_plot_mean <- list()
  
for(male in male_vec) {
    
  tmp_data <- data_fit_brms %>% filter(male == !!male)
  motif_count <- tmp_data$y
  tmp_mean <- data_epred %>% filter(male == !!male)

  tmp_plot_mean <- ggplot(data = tmp_mean,
                            aes(x = x, y = motif_count)) +
    ylim(0, max(motif_count)*1.1) +
    stat_lineribbon(aes(y = .epred)) +
    scale_fill_brewer(palette = "Greys") +
    scale_color_brewer(palette = "Set2") +
    geom_point(data = tmp_data, aes(x = x, y = y), color = "Red") +
    labs(title=male) +
    theme(legend.position="none")
  #print(tmp)
  list_plot_mean[[male]] <- tmp_plot_mean
  
}

tmp_plot <- plot_grid(
  plotlist = list_plot_mean,
  ncol = 4
)

data_grid <- data_fit_brms %>%
  group_by(male) %>%
  data_grid(x = seq_range(c(20, 40), n = 51))

plot_model[["mean"]] <- tmp_plot

tmp_plot

filename <- paste0("data-epred-vs-temp_", filename_desc, ".pdf")
ggsave(filename = filename, path = file.path(output_dir, "figures"),
       width = 8, height = 11, units = "in",
       scale = 1,
       dpi=300,
       bg = "white")
```

```{r}

list_plot_data <- list()

for(male in male_vec) {


  tmp_data <- data_fit_brms %>% filter(male == !!male)
  motif_count <- tmp_data$y
  tmp_pred  <- data_pred %>% filter(male ==!!male)
  tmp_plot_data <- ggplot(data = tmp_pred,
                          aes(x = x, y = motif_count)) +
    ylim(0, max(motif_count)*1.1) +
    stat_lineribbon(aes(y = .prediction),
                    .width = c(.95, .80, .50),
                    alpha = 1/4) +
    geom_point(data = tmp_data, aes(x = x, y = y), color = "Red") +
    scale_fill_brewer(palette = "Greys") +
    #scale_color_brewer(palette = "Set2") +
    labs(title=male) +
    theme(legend.position="none")
  print(tmp_plot_data)
  list_plot_data[[male]] <- tmp_plot_data
}

  
  #gridExtra::grid.arrange(grobs = plot_model_list)
  #
  #plot_tmp <- plot_grid(plotlist = plot_model_list,
  #                  ncol = 3)


plot_grid(
  plotlist = list_plot_data,
  ncol = 4,
  title = "data"
)


plot_model[["data"]] <- tmp_plot_data




```

## Combine Scatter Plots and Model vs Data Plots

```{r}

plot_combo <- list()

for(prediction in c("data")) {

    list_tmp <- list()
    for(male in male_vec) {
      list_tmp[[male]] <-
        plot_grid(
          plotlist = list(
            scatter_list[[male]],
            plot_model[[prediction]][[male]] +
              labs(title = NULL) +
              xlab(NULL) +
              ylab(NULL)
          )
        )  + labs(title = male)
    }

  plot_tmp <- plot_grid(
      plotlist = list_tmp,
      ncol = 2,
      title = prediction
    )
    print(plot_tmp)
    plot_combo[[prediction]] <- plot_tmp

}

```

## Exit rendering
```{r}

knitr::knit_exit()

```
